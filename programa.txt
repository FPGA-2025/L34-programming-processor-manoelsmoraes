.globl _boot
.section .text

_boot:
    # Inicializa os primeiros dois números
    addi x5, x0, 0        # t0 = 0 (Fibonacci[0])
    addi x6, x0, 1        # t1 = 1 (Fibonacci[1])

    # Armazena os dois primeiros valores na memória
    lui x7, 0x0           # x7 = base do endereço (ajustado a seguir)
    addi x7, x7, 0x80     # x7 = 0x80 (base address)
    sw x5, 0(x7)          # Mem[0x80] = 0
    sw x6, 4(x7)          # Mem[0x84] = 1

    # Calcula o 3º número
    add x8, x5, x6        # x8 = x5 + x6 (1)
    sw x8, 8(x7)          # Mem[0x88] = 1

    # Calcula o 4º número
    add x5, x6, x8        # x5 = x6 + x8 (2)
    sw x5, 12(x7)         # Mem[0x8C] = 2

    # Calcula o 5º número
    add x6, x8, x5        # x6 = x8 + x5 (3)
    sw x6, 16(x7)         # Mem[0x90] = 3

loop:
    j loop                # loop infinito para encerrar o programa
